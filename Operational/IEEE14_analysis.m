clc
clear
close all

% Load the base case data 
mpc = loadcase('case14_mod'); 

% Number of branches and buses
    num_branches = size(mpc.branch, 1);
    num_buses = size(mpc.bus, 1);

% Storage for results
    contingency_results = cell(num_branches, 1);
    flow_performance_index = zeros(num_branches, 1);
    voltage_performance_index = zeros(num_branches, 1);
    total_performance_index = NaN(num_branches, 1);

% Voltage limits and reference voltage
    V_max = mpc.bus(:, 12);  % Column 12 is the max voltage limit
    V_min = mpc.bus(:, 13);  % Column 13 is the min voltage limit
    V_ref = mpc.bus(:, 8);   % Column 8 is the reference voltage
    V_diff = V_max - V_min;  % Difference between max and min voltages

% ----------------- Run base case power flow --------------------------
    base_results = runpf(mpc);

% ----------------- Perform N-1 contingency analysis ------------------
    for k = 1:num_branches
        % Create a copy of the original case
        mpc_contingency = mpc;

        % Remove the k-th branch
        mpc_contingency.branch(k, :) = [];
        
       % Detect islanding
        G = graph(mpc_contingency.branch(:, 1), mpc_contingency.branch(:, 2));
        bins = conncomp(G);
        largest_component = mode(bins); % Find the largest connected component
        islanded_buses = find(bins ~= largest_component);

        % Check for islanding
        if ~isempty(islanded_buses)
            % Display message about islanding
            fprintf('\nAdministering contingency for line %d-%d\n', mpc.branch(k, 1), mpc.branch(k, 2));
            fprintf('Islanding detected. Load flow not executed for this contingency.\n');
            % Skip load flow execution for this contingency
            continue;
        end

         % Display the current contingency being administered
        fprintf('\nAdministering contingency for line %d-%d\n', mpc.branch(k, 1), mpc.branch(k, 2));

        % Run power flow for the contingency case
        results = runpf(mpc_contingency);

        % Store results
        contingency_results{k} = results;

        % Calculate Flow Performance Index (FPI)
        branch_flows = results.branch(:, 14);  % Column 14 is the branch flow
        branch_max_capacities = mpc_contingency.branch(:, 6);  % Column 6 is the rateA (max capacity)

        % Ensure arrays have the same length
        min_len = min(length(branch_flows), length(branch_max_capacities));
        flow_violations = (branch_flows(1:min_len) ./ branch_max_capacities(1:min_len)).^2;
        flow_performance_index(k) = sum(flow_violations);

        % Calculate Voltage Performance Index (VPI)
        bus_voltages = results.bus(:, 8);  % Column 8 is the bus voltage magnitude

        % Ensure arrays have the same length
        min_len = min([length(bus_voltages), length(V_ref), length(V_diff)]);
        voltage_violations = ((bus_voltages(1:min_len) - V_ref(1:min_len)) ./ V_diff(1:min_len)).^2;
                voltage_performance_index(k) = sum(voltage_violations);

        % Calculate Total Performance Index (TPI)
        total_performance_index(k) = flow_performance_index(k) + voltage_performance_index(k);
    end

    % Display results
    for k = 1:num_branches
        
        if isempty(contingency_results{k})
            fprintf('Contingency: Branch %d-%d Outage\n', mpc.branch(k, 1), mpc.branch(k, 2));
            fprintf('Flow Performance Index (FPI): NaN\n');
            fprintf('Voltage Performance Index (VPI): NaN\n');
            fprintf('Total Performance Index (TPI): NaN\n');
            fprintf('Load flow not executed due to islanding.\n\n');
            continue;
        end

        fprintf('Contingency: Branch %d-%d Outage\n', mpc.branch(k, 1), mpc.branch(k, 2));
        fprintf('Flow Performance Index (FPI): %.4f\n', flow_performance_index(k));
        fprintf('Voltage Performance Index (VPI): %.4f\n', voltage_performance_index(k));
        fprintf('Total Performance Index (TPI): %.4f\n', total_performance_index(k));

     
        fprintf('Bus Voltages:\n');
        disp(contingency_results{k}.bus(:, [1, 8])); % Bus number and voltage magnitude
        fprintf('Branch Flows:\n');
        disp(contingency_results{k}.branch(:, [1, 2, 14])); % From bus, to bus, and branch power flow

        % Check for violations
        branch_flows = contingency_results{k}.branch(:, 14);
        branch_max_capacities = mpc_contingency.branch(:, 6);

        % Ensure arrays have the same length
        min_len = min(length(branch_flows), length(branch_max_capacities));
        flow_violations_percentage = max((branch_flows(1:min_len) ./ branch_max_capacities(1:min_len) - 1) * 100, 0);
        fprintf('Flow Violations (%%):\n');
        disp(flow_violations_percentage);

        bus_voltages = contingency_results{k}.bus(:, 8);

        % Ensure arrays have the same length
        min_len = min(length(bus_voltages), length(V_ref));
        voltage_violations_percentage = max((abs(bus_voltages(1:min_len) - V_ref(1:min_len)) - 0.05) * 100, 0);
        fprintf('Voltage Violations (%%):\n');
        disp(voltage_violations_percentage);

        fprintf('\n');
    end


% Display results in a table format
contingency_table = cell(num_branches, 3);
for k = 1:num_branches
    % Determine the buses connected by the k-th branch
    from_bus = mpc.branch(k, 1);
    to_bus = mpc.branch(k, 2);
    
    % Store contingency description
    contingency_table{k, 1} = sprintf('Line %d-%d', from_bus, to_bus);
    
    % Store performance indices
        contingency_table{k, 2} = flow_performance_index(k);
        contingency_table{k, 3} = voltage_performance_index(k);
        contingency_table{k, 4} = total_performance_index(k);
end

% Convert to table for better display
contingency_table = cell2table(contingency_table, ...
    'VariableNames', {'Contingency', 'PI_Flow', 'PI_Volt', 'PI_Total'});

% Display the table
disp(contingency_table);


